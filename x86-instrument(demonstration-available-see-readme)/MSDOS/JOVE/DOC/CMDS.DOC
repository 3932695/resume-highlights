
:entry "abort-char" "Variable"
This variable defines JOVE'S'S abort character.  When JOVE reads this
character from the keyboard, it stops what it is doing (unless the
character is quoted in some way).  Unfortunately, JOVE won't notice
the character until it reads from the keyboard.  The default value is
^G.  See also "interrupt-character".

:entry "add-lisp-special" "Command"
This command is to tell JOVE what identifiers require special
indentation in lisp mode.  Lisp functions like "defun" and "let" are
two of the default functions that get treated specially.  This is just
a kludge to define some of your own.  It prompts for the function
name.

:entry "allow-^S-and-^Q" "Variable"
This variable, when set, tells JOVE that your terminal will not need
to use the characters ^S and ^Q for flow control, in which case JOVE
will instruct the system's tty driver to pass them through as normal
characters.  Otherwise, if the tty driver was already using these
characters for flow control, it will continue to do so.  Certain
terminals and communications systems require that this variable be set
"off"; in other circumstances it is better set "on".

:entry "allow-bad-characters-in-filenames" "Variable"
If set, this variable permits the creation of filenames which contain
"bad" characters such as those from the set *&%!"`[]{}.  These files
are harder to deal with, because the characters mean something to the
shell.  The default value is "off".

:entry "allow-bad-filenames" "Variable"
This is the obsolete name for "allow-bad-characters-in-filenames".

:entry "append-region" "Command"
This appends the region to a specified file.  If the file does not
already exist it is created.

:entry "apropos" "Command"
This types out each command, variable and macro with the specified
string in its name ("?" matches every name).  For each command and
macro that contains the string, the key sequence that can be used to
execute the command or macro is printed; with variables, the current
value is printed.  So, to find all the commands that are related to
windows, you type

     : apropos window<Return> .


:entry "auto-case-abbrev" "Variable"
When this variable is "on" (the default), word abbreviations are
adjusted for case automatically.  If the abbreviation is typed with no
uppercase letter, the expansion is not changed; if it is typed with
one or more uppercase letters, the first character in the expansion is
capitalized; additionally, if the abbreviation is typed with more than
one uppercase letter, each letter in the expansion immediately
preceded by whitespace or - is capitalized.  For example, if "jove"
were the abbreviation for "jonathan's own version of EMACS", the
following table shows how the abbreviation would be expanded.

     jove   jonathan's own version of EMACS
     Jove   Jonathan's own version of EMACS
     JOVE   Jonathan's Own Version Of EMACS
     JoVe   Jonathan's Own Version Of EMACS

When this variable is "off", upper and lower case are distinguished
when looking for the abbreviation, i.e., in the example above, "JOVE"
and "Jove" would not be expanded unless they were defined separately.
See also the "word-abbrev-mode" command.

:entry "auto-execute-command" "Command"
This tells JOVE to execute a command automatically when a file whose
name matches a specified pattern is read.  The first argument is the
command you wish to have executed.  The second argument is the
pattern, a regular expression that is matched against the start of the
file name.  If you wish to match a suffix, start the pattern with ".*
"; to match every file, use that as the whole pattern.  Any numeric
argument will be passed on to the command when it is executed (this is
useful when combined with commands that adjust a minor mode).  For
example, if you want to be in "show-match-mode" when you edit C source
files (that is, files that end with ".c" or ".h") you can type

     : auto-execute-command show-match-mode .*\.[ch]$

Actually, this command toggles the Show Match minor mode, but since it
is initially off, it will have the desired effect.  For more certain
control, give the "auto-execute-command" a non-zero numeric argument:
this will be passed on to the "show-match-mode".

:entry "auto-execute-macro" "Command"
This is like "auto-execute-command" except you use it to execute
macros automatically instead of built-in commands.

:entry "auto-fill-mode" "Command"
This turns on or off the Auto Fill minor mode in the selected buffer.
Without a numeric argument, the command toggles the mode; with a zero
argument, the mode is turned off; with a non-zero argument, the mode
is turned on.  When JOVE is in Auto Fill mode it automatically breaks
lines for you when you reach the right margin so you don't have to
remember to hit Return.  JOVE uses 78 as the right margin but you can
change that by setting the variable "right-margin" to another value.

:entry "auto-indent-mode" "Command"
This turns on or off Auto Indent minor mode in the selected buffer.
Without a numeric argument, the command toggles the mode; with a zero
argument, the mode is turned off; with a non-zero argument, the mode
is turned on.  When JOVE is in Auto Indent mode, the "newline" command
(which is normally bound to Return) acts identically to "newline-and-
indent":  the new line is indented to the same position as the line
you were just on.  This is useful for lining up C code (or any other
language (but what else is there besides C?)).  Furthermore, if a line
is broken because of Auto Fill mode, and Auto Indent mode is on, the
new line will be indented as the old line was.

:entry "backward-character" "Command"
This moves point backward over a single character or line-separator.
Thus if point is at the beginning of the line it moves to the end of
the previous line.

:entry "backward-list" "Command"
This moves point backward over a list, which is any text between
properly matching (...), [...] or {...}.  It first searches backward
for a ")" and then moves to the matching "(".  This is useful when you
are trying to find unmatched parentheses in a program.  Arguments are
accepted, and negative arguments search forwards.  See also
"backward-s-expression".

:entry "backward-paragraph" "Command"
This moves point backward to the beginning of the current or previous
paragraph.  Paragraphs are bounded by lines that match "paragraph-
delimiter-pattern" (by default, those that are empty or look like
troff or TeX commands).  A change in indentation may also signal a
break between paragraphs, except that JOVE allows the first line of a
paragraph to be indented differently from the other lines.  Arguments
are accepted, and negative arguments search forwards.

:entry "backward-s-expression" "Command"
This moves point backward over an s-expression, that is over a Lisp
atom or a C identifier (depending on the major mode) ignoring
punctuation and whitespace; or, if the nearest preceding significant
character is one of ")]}", over a list as in "backward-list".
Arguments are accepted, and negative arguments search forwards.

:entry "backward-sentence" "Command"
This moves point backward to the beginning of the current or previous
sentence.  JOVE considers the end of a sentence to be the characters
".", "!" or "?" followed by a Return or by one or more spaces.
Arguments are accepted, and negative arguments search forwards.

:entry "backward-up-list" "Command"
This is similar to "backward-list" except it backs up and OUT of the
enclosing list.  In other words, it moves backward to whichever of
"([{" would match one of ")]}" if you were to type it right then.
Arguments are accepted, and negative arguments search forwards as in
"down-list".

:entry "backward-word" "Command"
This moves point backward to the beginning of the current or previous
word.  Arguments are accepted, and negative arguments search forwards.

:entry "bad-filename-extensions" "Variable"
This contains a list of words separated by spaces which are to be
considered bad filename extensions, and so will not be included in
filename completion.  The default contains, amongst much else, ".o" so
if you have "jove.c" and "jove.o" in the same directory, the filename
completion will not complain of an ambiguity because it will ignore
"jove.o".

:entry "begin-kbd-macro" "Command"
This starts defining the keyboard macro by remembering all your key
strokes until you execute "end-kbd-macro", by typing "^X )".  Because
of a bug in JOVE you shouldn't terminate the macro by typing "ESC X
end-kbd-macro"; "end-kbd-macro" must be bound to "^X )" in order to
make things work correctly.  The "execute-kbd-macro" command will
execute the remembered key strokes.  Sometimes you may want a macro to
accept different input each time it runs.  To see how to do this, see
the "make-macro-interactive" command.

:entry "beginning-of-file" "Command"
This moves point backward to the beginning of the buffer.  This
sometimes prints the "[Point pushed]" message to indicate that JOVE
has set the mark so you can go back to where you were if you want.
See also the variable "mark-threshold".

:entry "beginning-of-line" "Command"
This moves point to the beginning of the current line.

:entry "beginning-of-window" "Command"
This moves point to the beginning of the active window.  If there is a
numeric argument, point moves that many lines below the top line.
With the default bindings, the sequence "ESC ," is the same as "ESC <"
("beginning-of-file") but without the shift key on the "<", and can
thus easily be remembered.

:entry "bind-keymap-to-key" "Command"
This is like "bind-to-key" except that you use it to attach a key
sequence to a named keymap.  The only reasonable use is to bind some
extra key to "ESC-map" for keyboards that make typing ESC painful.

:entry "bind-macro-to-key" "Command"
This is like "bind-to-key" except you use it to attach a key sequence
to a named macro.

:entry "bind-macro-to-word-abbrev" "Command"
This command allows you to bind a macro to a previously defined word
abbreviation.  Whenever you type the abbreviation, it will first be
expanded as an abbreviation (which could be empty, of course), and
then the macro will be executed.  Note that if the macro moves point
around, you should first "set-mark" and then "exchange-point-and-
mark".

:entry "bind-to-key" "Command"
This attaches a key sequence to an internal JOVE command so that
future hits on that key sequence invoke that command.  This is called
a global binding, as compared to local bindings and process bindings.
Any previous global binding of this key sequence is discarded.  For
example, to make "^W" erase the previous word, you type

     : bind-to-key kill-previous-word ^W .

It isn't possible to have two globally bound key sequences where one
is a prefix of the other: JOVE wouldn't know whether to obey the
shorter sequence or wait for the longer sequence.  Normally, when the
"bind-to-key" command is issued interactively, the key sequence is
taken to end one keystroke after the longest sequence matching any
proper prefix of another binding (thus no new prefix can be created).
If the command is given a numeric argument, the key sequence is taken
up to the next Return keystroke (kludge!); bindings to any prefix of
the sequence are discarded.  When the command is issued from a
"source"d file, the key sequence is taken up to the end of the line
(it is also processed so that control characters can and should be
entered using the ^A notation).

Note that neither process nor local bindings are changed by this
command, although they can be eclipsed.  Given a choice between
bindings, the shortest is executed; if there is still a choice, a
process binding is preferred to a local binding, and a local binding
is preferred to a global binding.

:entry "buffer-position" "Command"
This displays the current file name, current line number, total number
of lines, current character number, total number of characters,
percentage of the way through the file, and the position of the cursor
in the current line.

:entry "c-argument-indentation" "Variable"
This variable describes how to indent lines which are part of nested
expressions in C.  The default is -1, which means to indent a
continued line by lining it up with the first argument of the current
expression.  Otherwise, the line will be indented by "c-argument-
indentation" characters past the indent of the first line of the
expression.  For example, the default value produces:

       Typeout(fmt, itoa(bcount++), line_cnt(b, nbuf),
               TypeNames[b->b_type],
               IsModified(b) ? "*" : b->b_ntbf ? "+" : NullStr,
               buf_width, b->b_name, filename(b));

:entry "c-indentation-increment" "Variable"
This defines a set of tabstops independent of the value of "tab-
width".  This value will be used in C mode, and JOVE will insert the
correct number of Spaces and Tabs to get the right behavior.  For
programmers that like to indent with 4 spaces, set this value to 4.
Some people prefer to set this to 4 and leave tab-width set to 8.
This will create files whose indentation steps in 4-space increments,
and which look the same anywhere that tabs are expanded to 8 spaces
(i.e. in most settings).  Others prefer to have one tab character per
indentation level, then fiddle the tab expansion width to get the
appearance they like.  They should set both "c-indentation-increment"
and "tab-width" to 4.  Whenever using a non-standard tab width ("tab-
width") you should only use tabs for indentation, and use spaces for
all columnar alignment later in the lines.

:entry "c-mode" "Command"
This turns on the C major mode in the currently selected buffer.  When
in C or Lisp mode, Tab, "}", and ")" behave a little differently from
usual: They are indented to the "right" place for C (or Lisp)
programs.  In JOVE, the "right" place is simply the way the author
likes it (but I've got good taste).

:entry "case-character-capitalize" "Command"
This capitalizes the character after point, i.e., the character under
the cursor.  If a negative argument is supplied that many characters
before point are upper cased.

:entry "case-ignore-search" "Variable"
This variable, when "on", tells JOVE to treat upper and lower case the
same when searching.  Thus "jove" would match "JOVE", and "JoVe" would
match either.  The default value of this variable is "off".

:entry "case-region-lower" "Command"
This changes all the upper case letters in the region to their lower
case equivalents.

:entry "case-region-upper" "Command"
This changes all the lower case letters in the region to their upper
case equivalents.

:entry "case-word-capitalize" "Command"
This capitalizes the current word by making the current letter upper
case and making the rest of the word lower case.  Point is moved to
the end of the word.  If point is not positioned on a word it is first
moved forward to the beginning of the next word.  If a negative
argument is supplied that many words before point are capitalized.
This is useful for correcting the word just typed without having to
move point to the beginning of the word yourself.

:entry "case-word-lower" "Command"
This lower-cases the current word and leaves point at the end of it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to the beginning
of the next word.  If a negative argument is supplied that many words
before point are converted to lower case.  This is useful for
correcting the word just typed without having to move point to the
beginning of the word yourself.

:entry "case-word-upper" "Command"
This upper-cases the current word and leaves point at the end of it.
If point is in the middle of a word the rest of the word is converted.
If point is not in a word it is first moved forward to the beginning
of the next word.  If a negative argument is supplied that many words
before point are converted to upper case.  This is useful for
correcting the word just typed without having to move point to the
beginning of the word yourself.

:entry "cd" "Command"
This changes the current directory.

:entry "character-to-octal-insert" "Command"
This inserts a Back-slash followed by the ascii value of the next
character typed.  For example, "^G" inserts the string "\007".

:entry "clear-and-redraw" "Command"
This clears the entire screen and redraws all the windows.  Use this
when JOVE gets confused about what's on the screen, or when the screen
gets filled with garbage characters or output from another program.

:entry "comment-format" "Variable"
This variable tells JOVE how to format your comments when you run the
command "fill-comment".  Its format is this:

     <open pattern>%!<line header>%c<line trailer>%!<close pattern>

The %!, %c, and %! must appear in the format; everything else is
optional.  A newline (represented by %n) may appear in the open or
close patterns.  %% is the representation for %.  The default comment
format is for C comments.  See "fill-comment" for more details.

:entry "compile-it" "Command"
This compiles your program by running the UNIX command "make" into a
buffer, and automatically parsing the error messages that are created
(if any).  See the "parse-errors" command.  If "compile-it" is given a
numeric argument, it will prompt for a command to run in place of the
plain make and the command you enter will become the new default.  See
also "error-format-string" which makes it possible to parse errors of
a different format and see also the variable "error-window-size".

:entry "continue-process" "Command"
This sends the signal SIGCONT to the interactive process in the
current buffer, IF the process is currently stopped.

:entry "copy-region" "Command"
This takes all the text in the region and copies it onto the kill ring
buffer.  This is just like running "kill-region" followed by the
"yank" command.  See the "kill-region" and "yank" commands.

:entry "current-error" "Command"
This moves to the current error in the list of parsed errors.  See the
"next-error" and "previous-error" commands for more detailed
information.

:entry "date" "Command"
This prints the date on the message line.

:entry "dbx-format-string" "Variable"
This is the default regular-expression search string used by JOVE to
parse output from "dbx" running in a shell process (see the "process-
dbx-output" command).  You shouldn't have to change this unless you
are using "gdb" or some other symbolic debugger.

:entry "define-global-word-abbrev" "Command"
This defines a global abbreviation.  See the "word-abbrev-mode"
command.

:entry "define-macro" "Command"
This provides a different mechanism for defining keyboard macros.
Instead of gathering keystrokes and storing them into the "keyboard-
macro" (which is how "begin-kbd-macro" works), "define-macro" prompts
for a macro name (terminated with Space, or Newline) and then for the
actual macro body.  If you wish to specify control characters in the
macro, you may simply insert them (using the "quoted-insert" command)
or by inserting the character '^' followed by the appropriate letter
for that character (e.g., ^A would be the two characters '^' followed
by 'A').  You may use Back-slash to prevent the '^' from being
interpreted as part of a control character when you really wish to
insert one (e.g., a macro body "\^foo" would insert the string "^foo"
into the buffer, whereas the body "^foo" would be the same as typing
^F and then inserting the string "oo").  See "write-macros-to-file" to
see how to save macros.

:entry "define-mode-word-abbrev" "Command"
This defines a mode-specific abbreviation.  See the "word-abbrev-mode"
command.

:entry "delete-blank-lines" "Command"
This deletes all the blank lines around point.  This is useful when
you previously opened many lines with the "newline-and-backup" command
and now wish to delete the unused ones.

:entry "delete-buffer" "Command"
This deletes a buffer and frees up all the memory associated with it.
Be careful(!) - once a buffer has been deleted it is gone forever.
JOVE will ask you to confirm if you try to delete a buffer that needs
saving.  This command is useful for when JOVE runs out of space to
store new buffers.  See also the "erase-buffer" command and the
"kill-some-buffers" command.

:entry "delete-current-window" "Command"
This deletes the active window and moves point into one of the
remaining ones.  It is an error to try to delete the only remaining
window.

:entry "delete-next-character" "Command"
This deletes the character that's just after point (that is, the
character under the cursor).  If point is at the end of a line, the
line-separator is deleted and the next line is joined with the current
one.  If an argument is given, that many characters are deleted and
placed on the kill ring.  If the argument is negative the deletion is
forwards.

:entry "delete-other-windows" "Command"
This deletes all the other windows except the current one.  This can
be thought of as going back into One Window mode.

:entry "delete-previous-character" "Command"
This deletes the character that's just before point (that is, the
character before the cursor).  If point is at the beginning of the
line, the line separator is deleted and that line is joined with the
previous one.  If an argument is given, that many characters are
deleted and placed on the kill ring.  If the argument is negative the
deletion is backwards.

:entry "delete-white-space" "Command"
This deletes all the Tabs and Spaces around point.

:entry "describe-bindings" "Command"
This types out a list containing each bound key and the command that
gets invoked every time that key is typed.  To make a wall chart of
JOVE commands, set "send-typeout-to-buffer" to "on" and JOVE will
store the key bindings in a buffer which you can save to a file and
then print.

:entry "describe-command" "Command"
This waits for you to type a command and then prints an explanation of
that command, together with its current bindings.

:entry "describe-key" "Command"
This waits for you to type a key and then tells the name of the
command that gets invoked every time that key is hit.  Once you have
the name of the command you can use the "describe-command" command to
find out exactly what it does.

:entry "describe-variable" "Command"
This prints an explanation of a specified variable.

:entry "digit" "Command"
Starts or continues the entry of a numeric argument with the digit
typed.  It continues reading digits until you type some other command.
Then that command is executed with the numeric argument you specified.

:entry "digit-0" "Command"
Starts or continues the entry of a numeric argument with the digit 0.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 0 key on the numeric keypad.

:entry "digit-1" "Command"
Starts or continues the entry of a numeric argument with the digit 1.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 1 key on the numeric keypad.

:entry "digit-2" "Command"
Starts or continues the entry of a numeric argument with the digit 2.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 2 key on the numeric keypad.

:entry "digit-3" "Command"
Starts or continues the entry of a numeric argument with the digit 3.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 3 key on the numeric keypad.

:entry "digit-4" "Command"
Starts or continues the entry of a numeric argument with the digit 4.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 4 key on the numeric keypad.

:entry "digit-5" "Command"
Starts or continues the entry of a numeric argument with the digit 5.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 5 key on the numeric keypad.

:entry "digit-6" "Command"
Starts or continues the entry of a numeric argument with the digit 6.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 6 key on the numeric keypad.

:entry "digit-7" "Command"
Starts or continues the entry of a numeric argument with the digit 7.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 7 key on the numeric keypad.

:entry "digit-8" "Command"
Starts or continues the entry of a numeric argument with the digit 8.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 8 key on the numeric keypad.

:entry "digit-9" "Command"
Starts or continues the entry of a numeric argument with the digit 9.
It continues reading digits until you type some other command.  Then
that command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the 9 key on the numeric keypad.

:entry "digit-minus" "Command"
Starts the entry of a numeric argument with a minus sign.  It
continues reading digits until you type some other command.  Then that
command is executed with the numeric argument you specified.
Sometimes it is handy to bind this to the - key on a numeric keypad.
In the absence of further digits and unless otherwise stated (e.g.
"next-page"), the argument -1 is assumed.

:entry "dirs" "Command"
This prints out the directory stack.  See the "cd", "pushd",
"pushlibd" and "popd" commands for more information.

:entry "disable-biff" "Variable"
When this is set, JOVE disables biff when you're editing and enables
it again when you get out of JOVE, or when you pause to the parent
shell or push to a new shell.  (This means arrival of new mail will
not be immediately apparent but will not cause indiscriminate writing
on the display).  The default is "off", although it is always safe to
set it "on", even on systems that do not provide the biff facility.
Note that the variable "mode-line" can be set up to announce the
arrival of new mail during a JOVE session.

:entry "display-bad-filenames" "Variable"
This is the obsolete name for "display-filenames-with-bad-extensions".

:entry "display-filenames-with-bad-extensions" "Variable"
This variable affects only filename completion, in particular, what
happens when "?" is typed while prompting for a file.  When this
variable is "on", any files that end with one of the extensions
defined by the variable "bad-filename-extensions" will be displayed
with an "!" in front of their names.  When "display-filenames-with-
bad-extensions" is "off" the files will not be displayed at all.  The
default value is "on".

:entry "down-list" "Command"
This is the opposite of "backward-up-list".  It enters the next list.
In other words, it moves forward to whichever of "([{" it first
encounters.  Arguments are accepted, and negative arguments search
backwards as in "backward-up-list".

:entry "dstop-process" "Command"
Send the signal SIGTSTP to the interactive process in the selected
buffer when next it tries to read input.  This is equivalent to
sending the "dsusp" character (which most people have set to ^Y) to
the process.  This only works if you are in a buffer bound to an
interactive process.

:entry "edit-word-abbrevs" "Command"
This creates (if necessary) a buffer with a list of each abbreviation
and the phrase it expands into, and enters a recursive edit to let you
change the abbreviations or add some more.  The format of this list is
"abbreviation:phrase" so if you add some more you should follow that
format.  It's probably simplest just to copy some already existing
abbreviations and edit them.  Use the "exit-jove" command to exit the
recursive edit.

:entry "end-kbd-macro" "Command"
This stops the definition of the keyboard macro.  Because of a bug in
JOVE, this must be bound to "^X )", or some key sequence which is one
or two characters long.  Anything else will not work properly.  See
"begin-kbd-macro" for more details.

:entry "end-of-file" "Command"
This moves point forward to the end of the buffer.  This sometimes
prints the "[Point pushed]" message to indicate that JOVE has set the
mark so you can go back to where you were if you want.  See also the
variable "mark-threshold".

:entry "end-of-line" "Command"
This moves point to the end of the current line.  If the line is too
long to fit on the screen, it will be scrolled horizontally.  This is
described with the variables "scroll-width" and "scroll-all-lines".

:entry "end-of-window" "Command"
This moves point to the last character in the active window.  If there
is a numeric argument, the point moves that many lines above the
bottom line.  With the default bindings, the sequence "ESC ." is the
same as "ESC >" ("beginning-of-file") but without the shift key on the
">", and can thus easily be remembered.

:entry "enhanced-keyboard" "Variable"
(IBM PC version only) This is a boolean variable which can be set to
enable the enhanced AT-style keyboard.  The enhanced keyboard contains
function keys and key combinations that are not supported on the
original IBM PCs and XTs.  The default value is determined by a bit in
the BIOS data area, but this method apparently does not work with a
few BIOS implementations.  WARNING: setting enhanced-keyboard "on" on
systems without an enhanced keyboard will lock up your system and
require you to reboot.

:entry "eof-process" "Command"
Sends EOF to the current interactive process.  This only works on
versions of JOVE running under versions of UNIX with pty's.

:entry "erase-buffer" "Command"
This erases the contents of the specified buffer.  This is like
"delete-buffer" except it only erases the contents of the buffer, not
the buffer itself.  If you try to erase a buffer that needs saving you
will be asked to confirm it.

:entry "error-format-string" "Variable"
This is the error format string that is used by "parse-errors" to find
the error messages in a buffer.  The way it works is by using this
string as a JOVE regular expression search string, where the \(...\)
regular expression feature is used to pick out the file name and line
number from the line containing an error message.  For instance, a
typical error message might look like this:

       "file.c", line 540: missing semi-colon

For strings of this format, an appropriate value for "error-format-
string" would be something like this:

       ^"\([^"]*\)", line \([0-9]*\):

What this means is, to find an error message, search for a line
beginning with a double-quote.  Then it says that all the following
characters up to another double-quote should be remembered as one
unit, namely the filename that the error is in (that is why the first
set of parentheses is surrounding it).  Then it says that after the
filename there will be the string ", line " followed by a line number,
which should be remembered as a single unit (which is why the second
set of parentheses is around that).  The only constraint on the error
messages is that the file name and line number appear on the same
line.  Most compilers seem to do this anyway, so this is not an
unreasonable restriction.

If you do not know how to use regular expressions then this variable
will be hard for you to use.  Also note that you can look at the
default value of this variable by printing it out, but it is a really
complicated string because it is trying to accommodate the outputs of
more than one compiler.

:entry "error-window-size" "Variable"
This is the percentage of the screen to use for the error-window on
the screen.  When you execute "compile-it" or "spell-buffer", "error-
window-size" percent of the screen will go to the error window.  If
the window already exists and is a different size, it is made to be
this size.  The default value is 20%.

:entry "exchange-point-and-mark" "Command"
This moves point to mark and makes mark the old point.  This is for
quickly moving from one end of the region to the other.

:entry "execute-kbd-macro" "Command"
This executes the keyboard macro.  If you supply a numeric argument
the macro is executed that many times.  See the "begin-kbd-macro"
command for more details.

:entry "execute-macro" "Command"
This executes a specified macro.  If you supply a numeric argument the
macro is executed that many times.

:entry "execute-named-command" "Command"
This is the way to execute a command that isn't bound to any key.
When you are prompted with ": " you can type the name of the command.
You don't have to type the entire name.  After typing a few
characters, Tab will fill in as many more as it can (as will Space,
but that will also obey the command if it is now unambiguous).  If you
are not sure of the name of the command, type "?" and JOVE will print
a list of all the commands that you could possibly match given what
you've already typed.  Once the command is unambiguous, typing Return
will cause it to be obeyed.

If you don't have any idea what the command's name is but you know it
has something to do with windows (for example), you can do "ESC X
apropos window" and JOVE will print a list of all the commands that
are related to windows.  If you find yourself constantly executing the
same commands this way you probably want to bind them to keys so that
you can execute them more quickly.  See the "bind-to-key" command.

:entry "exit-jove" "Command"
This exits JOVE.  If any buffers need saving JOVE will print a warning
message and ask for confirmation.  If you leave without saving your
buffers all your work will be lost.  If you made a mistake and really
do want to exit then you can.  If there are any interactive processes
running, JOVE will also ask whether they should be terminated.

If you are in a recursive editing level "exit-jove" will return you
from that.  The selected buffer will be set back to the buffer that
was current when the recursive edit was entered.  Normally, point will
be returned to its position at the time of entry, but if the "exit-
jove" command is given a numeric argument, point is left at its most
recent position within that buffer.

:entry "expand-environment-variables" "Variable"
When this variable is "on" JOVE will try to expand any strings of the
form "$var" into the value of the environment variable "var" when
asking for a filename.  For example, if you type "$HOME/.joverc",
"$HOME" will be replaced with your home directory.  The default value
is "on".

:entry "file-creation-mode" "Variable"
This variable has an octal value.  It contains the mode (see
"chmod"(1)) with which files should be created.  This mode gets
modified by your current umask setting (see "umask"(1)).  The default
value is usually 0666 or 0644.

:entry "files-should-end-with-newline" "Variable"
This variable indicates that all files should always have a newline at
the end.  This is often necessary for line printers and the like.
When set, if JOVE is writing a file whose last character is not a
newline, it will add one automatically.  The default value is "on".

:entry "fill-comment" "Command"
This command fills in your C comments to make them pretty and
readable.  This filling is done according the variable "comment-
format".

     /*
      * the default format makes comments like this.
      */

This can be changed by changing the "format-comment" variable.  Other
languages may be supported by changing the format variable
appropriately.  The formatter looks backwards from point for an open
comment symbol.  If found, all indentation is done relative to the
position of the first character of the open symbol.  If there is a
matching close symbol, the entire comment is formatted.  If not, the
region between the open symbol and point is reformatted.  The original
text is saved in the kill ring; a "yank-pop" command will undo the
formatting.

:entry "fill-paragraph" "Command"
This rearranges words between lines so that all the lines in the
current paragraph extend as close to the right margin as possible,
ensuring that none of the lines will be greater than the right margin.
The default value for "right-margin" is 78, but can be changed with
the "set" and "right-margin-here" commands.

The rearrangement may cause an end of line to be replaced by
whitespace.  Normally, this whitespace is a single space character.
If the variable "space-sentence-2" is "on", and the end of the line
was apparently the end of a sentence or the line ended with a colon,
two spaces will be used.  However, a sentence or colon followed by a
single space already within a line will not be altered.

JOVE has a complicated algorithm for determining the beginning and end
of the paragraph.  In the normal case JOVE will give all the lines the
same indent as they currently have, but if you wish to force a new
indent you can supply a numeric argument to "fill-paragraph" and JOVE
will indent each line to the column specified by the "left-margin"
variable.  See also the "left-margin" variable and "left-margin-here"
command.

:entry "fill-region" "Command"
This is like "fill-paragraph", except it operates on a region instead
of just a paragraph.

:entry "filter-region" "Command"
This sends the text in the region to a UNIX command, and replaces the
region with the output from that command.  For example, if you are
lazy and don't like to take the time to write properly indented C
code, you can put the region around your C file and "filter-region" it
through "cb", the UNIX C beautifier.  If you have a file that contains
a bunch of lines that need to be sorted you can do that from inside
JOVE too, by filtering the region through the UNIX "sort" command.
Before output from the command replaces the region JOVE stores the old
text in the kill ring.  If you are unhappy with the results a "yank-
pop" command will get back the old text.

:entry "find-file" "Command"
This reads a specified file into its own buffer and then selects that
buffer.  If you've already read this file into a buffer, that buffer
is simply selected.  If the file doesn't yet exist, JOVE will print
"(New file)" so that you know.  If possible, the buffer is named after
the filename (ignoring any directory part).

:entry "find-tag" "Command"
This finds the file that contains the specified tag.  JOVE looks up
tags by default in the "tags" file in the current directory, as
created by the UNIX command "ctags(1)".  You can change the default
tag name by setting the "tag-file" variable to another name.  If you
specify a numeric argument to this command, you will be prompted for a
tag file.  This is a good way to specify another tag file without
changing the default.

:entry "find-tag-at-point" "Command"
This finds the file that contains the tag that point is currently in.
See "find-tag".

:entry "first-non-blank" "Command"
This moves point (backwards or forwards) to the indent of the current
line.

:entry "forward-character" "Command"
This moves point forward over a single character or line-separator.
Thus if point is at the end of the line it moves to the beginning of
the next one.

:entry "forward-list" "Command"
This moves point forward over a list, which is any text between
properly matching (...), [...] or {...}.  It first searches forward
for a "(" and then moves to the matching ")".  This is useful when you
are trying to find unmatched parentheses in a program.  Arguments are
accepted, and negative arguments search backwards.  See also
"forward-s-expression".

:entry "forward-paragraph" "Command"
This moves point forward to the end of the current or next paragraph.
Paragraphs are bounded by lines that match "paragraph-delimiter-
pattern" (by default, those that are empty or look like troff or TeX
commands).  A change in indentation may also signal a break between
paragraphs, except that JOVE allows the first line of a paragraph to
be indented differently from the other lines.  Arguments are accepted,
and negative arguments search backwards.

:entry "forward-s-expression" "Command"
This moves point forward over an s-expression, that is over a Lisp
atom or a C identifier (depending on the major mode) ignoring
punctuation and whitespace; or, if the nearest succeeding significant
character is one of "([{", over a list as in "forward-list".
Arguments are accepted, and negative arguments search backwards.

:entry "forward-sentence" "Command"
This moves point forward to the end of the current or next sentence.
JOVE considers the end of a sentence to be the characters ".", "!" or
"?", followed possibly by "'", "''", or """, followed by a Return or
whitespace.  Arguments are accepted, and negative arguments search
backwards.

:entry "forward-word" "Command"
This moves point forward to the end of the current or next word.

:entry "fundamental-mode" "Command"
This sets the major mode to Fundamental.  Fundamental mode is the mode
of the Minibuf, and hence of anything typed in the message line.

:entry "gather-numeric-argument" "Command"
This command is one of two ways to specify a numeric argument to a
command.  Typing this command once means, Do the next command 4 times.
Typing it twice will do the next command 16 times, and so on.  If at
any point you type a number, then that number will be used instead of
4.  For instance, ^U 3 5 means do the next command 35 times (assuming
"gather-numeric-argument" is bound to ^U).

:entry "goto-line" "Command"
If a positive numeric argument is supplied, point moves to the
beginning of that line.  If the argument is negative, it indicates how
many lines from the end of the buffer to move point to.  If no
argument is supplied one is prompted for.

:entry "goto-window-with-buffer" "Command"
This command prompts for a buffer name and then selects that buffer.
If the buffer is currently being displayed in one of the windows, that
window is selected instead.

:entry "grind-s-expr" "Command"
When point is positioned on a "(", this re-indents that LISP
expression.

:entry "grow-window" "Command"
This makes the active window one line bigger.  This only works when
there is more than one window and provided there is room to change the
size.  See also "shrink-window".

:entry "handle-tab" "Command"
This handles indenting to the "right" place in C and Lisp mode, and
just inserts itself in Text mode.

:entry "highlight-attribute" "Variable"
(IBM PC version only) This specifies how the attribute (color) of a
character is to be changed when it is highlighted.  Highlighting is
indicated by exclusive oring this value with the normal attribute for
the character.  The default is 16.

:entry "highlight-mark" "Variable"
When this is on, jove will highlight the mark if currently visible.
The mark is highlighted with an underscore.

:entry "i-search-forward" "Command"
Incremental search.  Like search-forward except that instead of
prompting for a string and searching for that string all at once, it
accepts the string one character at a time.  After each character you
type as part of the search string, it searches for the entire string
so far.  When you like what it found, type Return to finish the
search.  You can take back a character with DEL and the search will
back up to the position before that character was typed.  ^G aborts
the search.

:entry "i-search-reverse" "Command"
Incremental search.  Like search-reverse except that instead of
prompting for a string and searching for that string all at once, it
accepts the string one character at a time.  After each character you
type as part of the search string, it searches for the entire string
so far.  When you like what it found, type Return to finish the
search.  You can take back a character with DEL and the search will
back up to the position before that character was typed.  ^G aborts
the search.

:entry "i-shell-command" "Command"
This is like "shell-command" except that it launches an interactive
process and so lets you continue with your editing while the command
is running.  This is really useful for long running commands with
sporadic output.  See also the variable "wrap-process-lines".

:entry "insert-file" "Command"
This inserts a specified file into the selected buffer at point.
Point is positioned at the beginning of the inserted file.

:entry "internal-tabstop" "Variable"
This is the obsolete name for "tab-width".

:entry "interrupt-character" "Variable"
This specifies what character should be used as the operating system's
tty driver interrupt character.  When this character is typed, the tty
driver generates SIGINT signal.  This will interrupt a non-interactive
process.  If no such process is running, JOVE'S will offer you the
option of continuing, or crashing JOVE'S (trying to save your work).
This is a crude and desperate way to stop JOVE'S.  Unfortunately there
is no way to turn off the interrupt character.  The default is ^].
See also "abort-char".

:entry "interrupt-process" "Command"
This sends the signal SIGINT to the interactive process in the
selected buffer.  This only works if you are inside a buffer bound to
an interactive process.

:entry "kill-next-word" "Command"
This kills the text from point to the end of the current or next word.
The killed text is sent to the kill ring.

:entry "kill-previous-word" "Command"
This kills the text from point to the beginning of the current or
previous word.  The killed text is sent to the kill ring.

:entry "kill-process" "Command"
This command prompts for a buffer name or buffer number (just as
"select-buffer" does) and then sends the process in that buffer the
signal SIGKILL.

:entry "kill-region" "Command"
This deletes the text in the region and saves it on the kill ring.
Commands that delete text but save it on the kill ring all have the
word "kill" in their names.  Use the "yank" command to get back the
most recent kill.

:entry "kill-s-expression" "Command"
This kills the text from point to the end of the current or next s-
expression.  The killed text is sent to the kill ring.

:entry "kill-some-buffers" "Command"
This goes through all the existing buffers and asks whether or not to
delete each one.  If you decide to delete a buffer, and it turns out
that the buffer is modified, JOVE will offer to save it first.  This
is useful for when JOVE runs out of memory to store lines (this only
happens on PDP-11's) and you have lots of buffers that you are no
longer using.  See also the "delete-buffer" command.

:entry "kill-to-beginning-of-sentence" "Command"
This kills from point to the beginning of the current or previous
sentence.  If a negative numeric argument is supplied it kills from
point to the end of the current or next sentence.  The killed text is
sent to the kill ring.

:entry "kill-to-end-of-line" "Command"
This kills from point to the end of the current line.  When point is
at the end of the line (discounting any white space) the line-
separator is also deleted and the next line is joined with current
one.  If a numeric argument is supplied that many lines are killed; if
the argument is negative that many lines before point are killed; if
the argument is zero the text from point to the beginning of the line
is killed.  The killed text is sent to the kill ring.

:entry "kill-to-end-of-sentence" "Command"
This kills from point to the end of the current or next sentence.  If
a negative numeric argument is supplied it kills from point to the
beginning of the current or previous sentence.  The killed text is
sent to the kill ring.

:entry "lc-ctype" "Variable"
This string variable determines how non-ASCII characters are
displayed, and which characters are to be considered as upper-case,
lower-case, printable, etc.  The default is the implementation-defined
native environment; under POSIX, it is determined by whichever of the
environment variables LC_ALL, LC_CTYPE or LANG is first found to be
set, and is otherwise "C".  Some useful values of "lc-ctype" might be:

     ""             Default: the native environment.
     "C"            Strict ASCII.  All other characters greater than \177
                    rendered in octal.
     "iso_8859_1"   Latin-1 alphabet.


:entry "left-margin" "Variable"
This is how far lines should be indented when Auto Indent mode is on,
or when the "newline-and-indent" command is run (usually by typing
Linefeed).  It is also used by "fill-paragraph" and Auto Fill mode.
If the value is zero (the default) then the left margin is determined
from the surrounding lines.

:entry "left-margin-here" "Command"
This sets the "left-margin" variable to the current position of point.
This is an easy way to say, "Make the left margin begin here," without
having to count the number of spaces over it actually is.

:entry "lisp-mode" "Command"
This turns on the Lisp major mode.  In Lisp mode, the characters Tab
and ")" are treated specially, similar to the way they are treated in
C mode.  Also, Auto Indent mode is affected, and handled specially.
See also the "c-mode" command.

:entry "list-buffers" "Command"
This types out a list containing various information about each
buffer.  The list looks like this:

      (* means the buffer needs saving)
      NO  Lines Type        Name           File
      --  ----- ----        ----           ----
      1   1     File        Main           [No file]
      2   1     Scratch   * Minibuf        [No file]
      3   519   File      * commands.doc   commands.doc

The first column lists the buffer's number.  When JOVE prompts for a
buffer name you can either type in the full name, or you can simply
type the buffer's number.  The second column is the number of lines in
the buffer.  The third says what type of buffer.  There are four
types: File, Scratch, Process and I-Process.  "File" is simply a
buffer that holds a file; "Scratch" is for buffers that JOVE uses
internally; "Process" is one that holds the output from a UNIX
command; "I-Process" is one that has an interactive process attached
to it.  The next column contains the name of the buffer.  And the last
column is the name of the file that's attached to the buffer.  In this
case, both Minibuf and commands.doc have been changed but not yet
saved.  In fact Minibuf won't be saved since it's a Scratch buffer.

:entry "list-processes" "Command"
This makes a list somewhat like "list-buffers" does, except its list
consists of the current interactive processes.  The list looks like
this:

      Buffer           Status           Pid       Command
      ------           ------           ---       -------
      *shell*          Running          18415     shell
      fgrep            Done             18512     fgrep -n Buffer *.c

The first column has the name of the buffer to which the process is
attached.  The second has the status of the process; if a process has
exited normally the status is "Done" as in fgrep; if the process
exited with an error the status is "Exit N" where N is the value of
the exit code; if the process was killed by some signal the status is
the name of the signal that was used; otherwise the process is
running.  The last column is the name of the command that is being
run.

:entry "local-bind-keymap-to-key" "Command"
This is like "local-bind-to-key" except that you use it to attach a
key sequence to a named keymap.  The only reasonable use is to bind
some extra key to "ESC-map" for keyboards that make typing ESC
painful.

:entry "local-bind-macro-to-key" "Command"
This is like "local-bind-to-key" except you use it to attach a key
sequence to a named macro.

:entry "local-bind-to-key" "Command"
This is like "bind-to-key", except that the binding is only enabled
when the selected buffer is the buffer that was current when the
command was executed.  In other words, the binding only applies to the
selected buffer.

:entry "macify" "Variable"
(Mac version only) When this variable is on, JOVE will use the
standard Macintosh file-selector dialog in place of the traditional
JOVE Minibuffer.

:entry "mail-check-frequency" "Variable"
This is how often (in seconds) JOVE should check your mailbox for
incoming mail.  If you set this to zero JOVE won't check for new mail.
See also the "mode-line", "mailbox" and "disable-biff" variables.  The
default is 60.

:entry "mailbox" "Variable"
Set this to the full pathname of your mailbox.  JOVE will look here to
decide whether or not you have any unread mail.  This defaults to
"/usr/spool/mail/$USER", where "$USER" is set to your login name.

:entry "make-backup-files" "Variable"
If this variable is set, then whenever JOVE writes out a file, it will
move the previous version of the file (if there was one) to
"#filename~".  This is often convenient if you save a file by
accident.  The default value of this variable is "off".

:entry "make-buffer-unmodified" "Command"
This makes JOVE think the selected buffer hasn't been changed even if
it has.  Use this when you accidentally change the buffer but don't
want it considered changed.  Watch the mode line to see the *
disappear when you use this command.

:entry "make-macro-interactive" "Command"
This command is meaningful only while you are defining a keyboard
macro, and when you are expecting input in the message line.
Ordinarily, when a command in a macro definition requires a trailing
text argument (file name, search string, etc.), the argument you
supply becomes part of the macro definition.  If you want to be able
to supply a different argument each time the macro is used, then while
you are defining it, you should give the "make-macro-interactive"
command just before typing the argument which will be used during the
definition process.  Note: you must bind this command to a key in
order to use it; you can't say "ESC X make-macro-interactive".

:entry "mark-threshold" "Variable"
This variable contains the number of lines point may move by before
the mark is set.  If, in a search or some other command that may move
point, point moves by more than this many lines, the mark is set so
that you may return easily.  The default value of this variable is 22
(one screenful, on most terminals).  See also the commands "search-
forward", "search-reverse", "beginning-of-file" and "end-of-file".

:entry "match-regular-expressions" "Variable"
When set, JOVE will match regular expressions in search patterns.
This makes special the characters ., *, [ and ].  See the JOVE Manual
for a full discussion of regular-expressions.

:entry "meta-key" "Variable"
You should set this variable to "on" if your terminal has a real Meta
key which forces the 8th bit of each character.  If your terminal has
such a key, then a key sequence like ESC Y can be entered by holding
down Meta and typing Y.  On the IBM PC, this variable affects how ALT
is interpreted.  On the Macintosh, it affects how Option is
interpreted.  NOTE: In some older UNIX systems, JOVE must switch the
tty to raw mode to accept the 8-bit characters generated by a meta
key.  Unfortunately, the "interrupt-character" does not generate an
interrupt in raw mode.

:entry "mode-line" "Variable"
The format of the mode line can be determined by setting this
variable.  The items in the line are specified using a format similar
to that used by "printf(3)", with the special things being marked as
"%x".  Digits may be used between the '%' and the 'x' to mean repeat
that many times.  'x' may be:

          C    checks for new mail, and displays "[New mail]" if there is any
               (see also the "mail-check-frequency" and "mailbox" variables)
          F    the current file name, with leading path stripped
          M    the current list of major and minor modes
          b    the selected buffer name
          c    the fill character (-)
          d    the current directory
          e    extra space in mode line is distributed evenly
               among the places %e is used (used for justifying,
               separating, or centering parts of the mode line)
          f    the current file name
          ixy  x, when the buffer's file has been changed behind JOVE's back,
               y, when not
          mxy  x, when the buffer is modified or y, when not
          n    the selected buffer number
          p    interactive process status for process windows
          s    space, but only if previous character is not a space
          t    the current time (updated automatically)
          w    a '>' for windows which are scrolled left
          [ ]  the square brackets printed when in a recursive edit
          ( )  items enclosed in %( ... %) will only be printed on
               the bottom mode line, rather than copied when the
               window is split

In addition, any other character is simply copied into the mode line.
Characters may be escaped with a backslash.  To get a feel for all
this, try typing "ESC X print mode-line" and compare the result with
your current mode line.

:entry "mode-line-attribute" "Variable"
(IBM PC version only) This specifies the screen attribute (color) for
characters in the mode line.  The default is 112 (black on white).

:entry "mode-line-should-standout" "Variable"
If set, the mode line will be printed in reverse video, if your
terminal supports it.  The default for this variable is "on".

:entry "name-kbd-macro" "Command"
This copies the keyboard macro and gives it a name freeing up the
keyboard macro so you can define some more.  Keyboard macros with
their own names can be bound to keys just like built in commands can.
See the "define-macro", "source" and "write-macros-to-file" commands.

:entry "newline" "Command"
This divides the current line at point moving all the text to the
right of point down onto the newly created line.  Point moves down to
the beginning of the new line.  In Auto Indent mode, the new line will
be indented to match the old line.

:entry "newline-and-backup" "Command"
This divides the current line at point moving all the text to the
right of point down onto the newly created line.  The difference
between this and "newline" is that point does not move down to the
beginning of the new line.

:entry "newline-and-indent" "Command"
This behaves in any mode the same way as "newline" does in Auto Indent
mode.

:entry "next-error" "Command"
This moves to the next error in the list of errors that were parsed
with "parse-errors".  In one window the list of errors is shown with
the current one always at the top.  If the file that contains the
error is not already in a buffer, it is read in.  Its buffer is
displayed in another window and point is positioned in this window on
the line where the error occurred.

:entry "next-line" "Command"
This moves point down to the corresponding position on the next line
(or the end of that line if it does not extend so far).

:entry "next-page" "Command"
This displays the next page of the selected buffer by taking the
bottom line of the window and redrawing the window with it at the top.
If there isn't another page in the buffer JOVE rings the bell.  If a
numeric argument of only - (with no digits) is supplied, the previous
page is displayed.  Otherwise, if a numeric argument is supplied the
screen is scrolled up that many lines, exactly as in the "scroll-up"
command; if the argument is negative the screen is scrolled down.

:entry "next-window" "Command"
This moves into the next window.  Windows live in a circular list so
when you're in the bottom window and you try to move to the next one
you are moved to the top window.  It is an error to use this command
with only one window.

:entry "number-lines-in-window" "Command"
This displays the line numbers for each line in the buffer being
displayed.  The number isn't actually part of the text; it's just
printed before the actual buffer line is.  To turn this off you run
the command again; it toggles.

:entry "one-key-confirmation" "Variable"
If this variable is set, a single keystroke of y or n is expected in
answer to yes/no questions.  Normally, a yes/no question must be
answered with any non-empty prefix of yes or no, followed by a Return

:entry "over-write-mode" "Command"
This turns Over Write minor mode on in the selected buffer.  Without a
numeric argument, the command toggles the mode; with a zero argument,
the mode is turned off; with a non-zero argument, the mode is turned
on.  When on, this mode changes the way the self-inserting characters
work.  Instead of inserting themselves and pushing the rest of the
line over to the right, they replace or over-write the existing
character.  Also, DEL replaces the character before point with a space
instead of deleting it.  When Over Write mode is on "OvrWt" is
displayed in the mode line.

:entry "page-next-window" "Command"
This displays the next page in the next window.  It switches to the
next window, performs a "next-page" command (with any numeric
argument), and switches back to the original window.  Note that an
argument of just "-" will thus display the previous page.

:entry "paren-flash" "Command"
This command causes the characters bound to it to be inserted, and
then to partake in C mode curly brace indentation, Lisp mode
parenthesis indentation, and the Show Match mode paren/curly-
brace/square-bracket flashing.

:entry "paragraph-delimiter-pattern" "Variable"
When JOVE is searching for a paragraph boundary, if this pattern (a
regular expression) matches the start of a line, that line is treated
as a paragraph delimiter.  The default pattern recognizes blank lines,
troff control lines, and lines starting with a TeX control sequence.

There is a special provision for TeX: if a line is matched by the
pattern, and the match is of exactly an initial \, that line is only
treated as a delimiter if the next line also starts with \.

:entry "paren-flash-delay" "Variable"
How long, in tenths of a second, JOVE should pause on a matching
parenthesis in Show Match mode.  The default is 5.

:entry "parse-errors" "Command"
This takes the list of C compilation errors (or the output from
another program in an acceptable format) in the selected buffer and
parses them for use with the "next-error", "previous-error" and
"current-error" commands.  This is a very useful tool and helps with
compiling C programs or, when used in conjunction with the UNIX "grep"
command, with making changes to a bunch of files.  JOVE finds each
file that has an error and remembers each line that contains an error.
It doesn't matter if later you insert or delete some lines in the
buffers containing errors; JOVE remembers where they are regardless.
"current-error" is automatically executed after one of the parse
commands, so you end up at the first error.  The variable "error-
format-string" specifies, by means of regular-expressions, the format
of errors to be recognized.  Its default value can handle messages
from "cc", "cpp", "lint" and "grep -n".

:entry "parse-spelling-errors-in-buffer" "Command"
This parses a list of words in the selected buffer and looks them up
in another buffer that you specify.  It is invoked automatically by
the "spell-buffer" command.

:entry "pause-jove" "Command"
This stops JOVE and returns control to the parent shell.  This only
works on systems that have the job control facility.  To return to
JOVE you type "fg" to the shell.

:entry "pop-mark" "Command"
JOVE remembers the last eight marks and you use "pop-mark" to go
backward through the ring of marks.  If you execute "pop-mark" enough
times you will eventually get back to where you started.  This command
is also executed when you run "set-mark" with a numeric argument.

:entry "popd" "Command"
This pops one entry off the directory stack.  Entries are pushed with
the "pushd" or "pushlibd" commands.  The names were stolen from the
C-shell and the behavior is the same.

:entry "previous-error" "Command"
This is the same as "next-error" except it goes to the previous error.
See "next-error" for documentation.

:entry "previous-line" "Command"
This moves point up to the corresponding position on the previous line
(or the end of that line if it does not extend so far).

:entry "previous-page" "Command"
This displays the previous page of the selected buffer by taking the
top line and redrawing the window with it at the bottom.  If a numeric
argument of only - (with no digits) is supplied, the next page is
displayed.  Otherwise, if a numeric argument is supplied the screen is
scrolled down that many lines, exactly as in the "scroll-down"
command; if the argument is negative the screen is scrolled up.

:entry "previous-window" "Command"
This moves into the previous window.  Windows live in a circular list
so when you're in the top window and you try to move to the previous
one you are moved to the bottom window.  It is an error to use this
command with only one window.

:entry "print" "Command"
This displays the value of a JOVE variable in the message line.

:entry "process-bind-keymap-to-key" "Command"
This is like "process-bind-to-key" except that you use it to attach a
key sequence to named keymap.  The only reasonable use is to bind some
extra key to "ESC-map" for keyboards that make typing ESC painful.

:entry "process-bind-macro-to-key" "Command"
This is like "process-bind-to-key" except you use it to attach a key
sequence to a named macro.

:entry "process-bind-to-key" "Command"
This command is identical to "bind-to-key", except that it only
affects your bindings when you are in a buffer attached to an
interactive process.  When you enter the process buffer, any keys
bound with this command will automatically take their new values.
When you switch to a non-process buffer, the old bindings for those
keys will be restored.  For example, you might want to execute

     process-bind-to-key stop-process ^C ^Z
     process-bind-to-key interrupt-process ^C ^C

Then, when you start up an interactive process and switch into that
buffer, ^C ^Z will execute "stop-process" and ^C ^C will execute
"interrupt-process".  Bindings effective only in process windows are
shown with a "Proc:"  prefix in this manual and by the "apropos" and
"describe-bindings" commands.

:entry "process-dbx-output" "Command"
This command only makes sense in a buffer running an interactive shell
process.  If you are running "dbx" in a window, JOVE will
automatically find the file you are currently stepping through and
display it in another window whenever you type "where" or while you're
stepping through a program, or when you reach a breakpoint.  The
string DBX will appear in the mode line along with the process status
when this feature is enabled.  See also the variable "dbx-format-
string".

:entry "process-newline" "Command"
This command is normally bound to Return as if by a "process-bind-to-
key" so that it will only be bound in a process window.  JOVE does two
different things depending on where you are when you hit Return.  When
you're in the last line of the interactive process buffer, point moves
to the end of the line, the line is terminated, and the line is made
available as input to the process.  When point is positioned in some
other line, that line is copied to the end of the buffer (with the
prompt stripped) and point is moved there with it, so you can then
edit that line before sending it to the process.  This command must be
bound to the key you usually use to enter shell commands (Return), or
else you won't be able to enter any.  See the variable "process-
prompt".

:entry "process-prompt" "Variable"
What a prompt looks like from the "shell" and "i-shell-command"
processes.  The default is "% ", the default C-shell prompt.  This is
actually a regular expression search string.  So you can set it to be
more than one thing at once using the \| operator.  For instance, for
LISP hackers, the prompt can be

     "% \|-> \|<[0-9]>: ".


:entry "process-send-data-no-return" "Command"
This is like "process-newline" except it sends everything to the
process without the newline.  Normally, when you type return in a
process buffer it sends everything you typed including the Return.
This command just provides a way to send data to the process without
having to send a newline as well.

:entry "push-shell" "Command"
This spawns a child shell and relinquishes control to it.  Within this
shell, $1 can be used to refer to the filename (if any) of the
selected buffer.  This works on any version of UNIX, but this isn't as
good as "pause-jove" because it takes time to start up the new shell
and you get a brand new environment every time.  To return to JOVE,
simply exit the shell.

:entry "pushd" "Command"
This pushes a directory onto the directory stack and cd's into it.  It
asks for the directory name but if you don't specify one it switches
the top two entries on the stack.  It purposely behaves the same as
C-shell's "pushd".

:entry "pushlibd" "Command"
Performs same function as "pushd" except that it pushes the Jove
sharable library directory.  This directory holds the system-wide
"jove.rc" and the text used by the "describe-command" and "describe-
variable" commands.  It is mainly intended for use with the "jove.rc"
file.

:entry "pwd" "Command"
This prints the pathname of the working directory, as in the UNIX
"pwd" command.

:entry "query-replace-string" "Command"
This replaces strings matching a specified regular-expression with a
specified replacement string.  When a match is found, point is moved
to it and then JOVE asks what to do.  The options are:

     Space or Y or y     to replace this match and go on to the next one.
     Period              to replace this match and then stop.
     DEL, BS, or N or n  to skip this match and go on to the next one.
     ^R or R or r        to enter a recursive edit.  This lets you temporarily
                         suspend the replace, do some editing, and then return
                         to continue where you left off.  To continue with the
                         "query-replace-string", use the "exit-jove" command.
     ^W                  to delete the match and then enter a recursive edit.
     ^U or U or u        to undo all changes to the last modified line and
                         continue the search from the start of that line.
     ! or P or p         to go ahead and replace the remaining matches without
                         asking, as in "replace-string".
     Return or Q or q    to stop the "query-replace-string".
     ^L                  to redraw the screen

It is often useful to include a piece of the matched string in the
replacement, especially if the piece was not matched by literal text.
To select which part of the matched string is to be used, the
corresponding part of the pattern is bracketed with \( and \).  More
than one set of brackets may be used, as long as they are properly
nested.  The matching substring is selected in the replacement string
using \ followed by a digit: \1 for the first, \2 for the second, and
so on.  Conveniently, \0 always stands for the complete matched
string, as if the whole regular expression were bracketed.  For
example, the following command will reverse pairs of comma-separated
numbers:

     : query-replace-string \([0-9]*\),\([0-9]*\) with \2,\1

The search for a match starts at point and goes to the end of the
buffer, so to replace in the entire buffer you must first go to the
beginning.  Each subsequent search starts at the position after the
previous match; if the previous match was an empty string, the search
is first advanced one character to prevent unbounded repetition.

:entry "quit-process" "Command"
Send the signal SIGQUIT to the interactive process in the selected
buffer.  This is equivalent to sending the "quit" character (which
most people have bound to ^\) to the process.  This only works if you
are in a buffer bound to an interactive process.

:entry "quoted-insert" "Command"
This lets you insert characters that normally would be executed as
other JOVE commands.  For example, to insert "^F" you type "^Q ^F"
(assuming "quoted-insert" is bound to ^Q).  NUL cannot be represented
in the buffer, so "quoted-insert" will insert "^@" in its stead.  On
the IBM PC under DOS, non-ASCII keystrokes are seen by JOVE as a hex
FF character followed by another character; "quoted-insert" will quote
both characters.

:entry "read-only-mode" "Command"
This turns on or off the Read-only minor mode.  Without a numeric
argument, the command toggles the mode; with a zero argument, the mode
is turned off; with a non-zero argument, the mode is turned on.  When
a buffer is in Read-only mode, any attempt to modify the buffer will
fail.  When a file is found, and it's not got write permission, JOVE
automatically puts the buffer in read-only mode.  This is very helpful
when you are in environments which use source control programs like
RCS and SCCS.  It prevents accidents like making a bunch of changes
and only THEN discovering that you haven't checked the file out for
making changes.

:entry "read-word-abbrev-file" "Command"
This reads a specified file that contains a bunch of abbreviation
definitions, and makes those abbreviations available.  See the "word-
abbrev-mode" command.

:entry "recursive-edit" "Command"
This enters a recursive editing level.  This isn't really very useful.
I don't know why it's available for public use.  I think I'll delete
it some day.

:entry "redraw-display" "Command"
This vertically centers the line containing point within the window.
If that line is already in place, the screen is first cleared and then
redrawn.  If a numeric argument is supplied, the line is positioned at
that offset from the top of the window.  For example, "ESC 0 ^L"
positions the line containing point at the top of the window (assuming
"redraw-display" is bound to ^L).

:entry "rename-buffer" "Command"
This lets you rename the selected buffer.

:entry "replace-in-region" "Command"
This is the same as "replace-string" except that it is restricted to
occurrences between point and the mark.

:entry "replace-string" "Command"
This replaces all occurrences of a specified string with a specified
replacement string.  This is just like "query-replace-string" except
that it replaces without asking.

:entry "right-margin" "Variable"
Where the right margin is for Auto Fill mode and the "fill-paragraph"
and "fill-region" commands.  The default is 78.

:entry "right-margin-here" "Command"
This sets the "right-margin" variable to the current position of
point.  This is an easy way to say, "Make the right margin begin
here," without having to count the number of spaces over it actually
is.

:entry "save-file" "Command"
This saves the selected buffer to the associated file.  This makes
your changes permanent so you should be sure you really want to do it.
If the buffer has not been modified "save-file" refuses to do the
save.  If you really do want to write the file you must use "write-
file".

:entry "scroll-all-lines" "Variable"
When this is "off", (the default) horizontal scrolling will only
affect the line containing point.  When it is "on", horizontal
scrolling will affect the whole window.  See also the "scroll-width"
variable.

:entry "scroll-bar" "Variable"
When this is turned "on", a section of the mode line at the foot of
each window is left in not-reverse-video, to show the position of the
window relative to the whole of the file represented by that buffer
(however, if the whole of the buffer is within the window, the whole
mode line remains inverted).

:entry "scroll-down" "Command"
This scrolls the screen one line down.  If the line containing point
moves past the bottom of the window, point is moved up to the top of
the window.  If a numeric argument is supplied that many lines are
scrolled; if the argument is negative the screen is scrolled up
instead.  See the "previous-page" command.

:entry "scroll-left" "Command"
This scrolls the text in the active window to the left.  If a numeric
argument is specified then the text is scrolled that number of
columns.  Otherwise, the text is scrolled by the number of columns
specified by the variable "scroll-width".  If the variable "scroll-
all-lines" is ON then "scroll-left" may actually do nothing if the
scrolling would cause point not to be visible.  A negative argument
scrolls right.  If the "mode-line" variable is suitably set, an
indication that the text is scrolled will be given in the mode line.

:entry "scroll-right" "Command"
This scrolls the text in the active window to the right.  If a numeric
argument is specified then the text is scrolled that number of
columns.  Otherwise, the text is scrolled by the number of columns
specified by the variable "scroll-width".  If the variable "scroll-
all-lines" is ON then "scroll-right" may actually do nothing if the
scrolling would cause point not to be visible.  A negative argument
scrolls left.

:entry "scroll-step" "Variable"
How many lines should be scrolled if the "previous-line" or "next-
line" commands move you off the top or bottom of the screen.  You may
wish to decrease this variable if you are on a slow terminal.  The
default value is 0, which means to center the current line in the
window.  If the value is negative, the behavior is slightly different.
If you move off the top of the window, and "scroll-step" is, say, -5
then the new line will be displayed 5 lines from the bottom of the
window.  If you move off the bottom of the window, the new line will
be positioned 5 lines from the top of the window.

:entry "scroll-up" "Command"
This scrolls the screen one line up.  If the line containing point
moves past the top of the window, point is moved down to the top of
the window.  If a numeric argument is supplied that many lines are
scrolled; if the argument is negative the screen is scrolled down
instead.  See also the "next-page" command.

:entry "scroll-width" "Variable"
Just as a buffer may be too long to be completely displayed in a
window, a line may be too wide.  JOVE handles wide lines through
horizontal scrolling, displaying only a portion of the line.  This
variable affects horizontal scrolling.  If point is outside the
displayed portion of its line, but is within the specified number of
columns beyond either side, the line is scrolled that much.
Otherwise, the line will be scrolled to center point.  The default
value is 10.  If the variable is 0, centering will always be used.
See also the "scroll-all-lines" variable.

:entry "search-exit-char" "Variable"
Set this to the character you want to use to exit incremental search.
The default is Newline, which makes "i-search" commands compatible
with normal string search.

:entry "search-forward" "Command"
This searches forward for a specified search string and positions
point at the end of the string if it's found.  If the string is not
found point remains unchanged.  This searches from point to the end of
the buffer, so any matches before point will be missed.  If point is
moved by more than the variable "mark-threshold", the old point will
be pushed.

:entry "search-forward-nd" "Command"
This is just like "search-forward" except that it doesn't assume a
default search string, and it doesn't set the default search string.
This is useful for defining macros, when you want to search for
something, but you don't want it to affect the current default search
string.

:entry "search-reverse" "Command"
This searches backward for a specified search string and positions
point at the beginning if the string if it's found.  If the string is
not found point remains unchanged.  This searches from point to the
beginning of the buffer, so any matches after point will be missed.
If point is moved by more than the variable "mark-threshold", the old
point will be pushed.

:entry "search-reverse-nd" "Command"
This is just like "search-reverse" except that it doesn't assume a
default search string, and it doesn't set the default search string.
This is useful for defining macros, when you want to search for
something, but you don't want it to affect the current default search
string.

:entry "select-buffer" "Command"
This selects a new or already existing buffer making it the current
one.  You can type either the buffer name or number.  If you type in
the name you need only type the name until it is unambiguous, at which
point typing Tab or Space will complete it for you.  If you want to
create a new buffer you can type Return instead of Space, and a new
empty buffer will be created.

:entry "select-buffer-1" "Command"
This selects buffer number 1, if it exists.

:entry "select-buffer-10" "Command"
This selects buffer number 10, if it exists.

:entry "select-buffer-2" "Command"
This selects buffer number 2, if it exists.

:entry "select-buffer-3" "Command"
This selects buffer number 3, if it exists.

:entry "select-buffer-4" "Command"
This selects buffer number 4, if it exists.

:entry "select-buffer-5" "Command"
This selects buffer number 5, if it exists.

:entry "select-buffer-6" "Command"
This selects buffer number 6, if it exists.

:entry "select-buffer-7" "Command"
This selects buffer number 7, if it exists.

:entry "select-buffer-8" "Command"
This selects buffer number 8, if it exists.

:entry "select-buffer-9" "Command"
This selects buffer number 9, if it exists.

:entry "self-insert" "Command"
This inserts the character that invoked it into the buffer at point.
Initially all but a few of the printing characters are bound to
"self-insert".  See also "paren-flash".

:entry "send-typeout-to-buffer" "Variable"
When this is "on" JOVE will send output that normally overwrites the
screen (temporarily) to a buffer instead.  This affects commands like
"list-buffers", "list-processes", "shell-command-with-typeout", and
commands that use completion.  The default value is "off".

:entry "set" "Command"
This sets a specified variable to a new value.

:entry "set-mark" "Command"
This sets the mark at the current position in the buffer.  It prints
the message "[Point pushed]" on the message line.  It says that
instead of "[Mark set]" because when you set the mark the previous
mark is still remembered on a ring of eight marks.  So "[Point
pushed]" means point is pushed onto the ring of marks and becomes the
value of "the mark".  To go through the ring of marks, use the "pop-
mark" command.  If you type this enough times you will get back to
where you started.  If a "set-mark" command is given a numeric
argument, it acts like a "pop-mark" command.

:entry "shell" "Variable"
The shell to be used with all the shell-* commands command.  If your
SHELL environment variable is set, it is used as the default value of
"shell"; otherwise "/bin/csh" is the default.  See also the
description of the "shell-flags" variable to see how to change the
flags passed to this shell.

:entry "shell" "Command"
This starts up an interactive shell in a window; if there is already
an interactive shell, it just selects that buffer.  JOVE uses "*
shell-n*" (where "n" is the argument of the command) as the name of
the buffer in which the interacting takes place.  Thus different
argument values refer to different interactive shells.  See the JOVE
manual for information on how to use interactive processes.  See also
the variable "wrap-process-lines".

:entry "shell-command" "Command"
This runs a UNIX command and places the output from that command in a
buffer.  Within the command, $1 can be used to refer the the filename
(if any) of the selected buffer.  JOVE creates a buffer that matches
the name of the command you specify and then attaches that buffer to a
window.  So, when you have only one window running, this command will
cause JOVE to split the window and attach the new buffer to that
window.  Otherwise, JOVE finds the most convenient of the available
windows and uses that one instead.  If the buffer already exists it is
first emptied (unless a numeric argument is specified).  If it's
already holding a file, not some output from a previous command, JOVE
asks permission before emptying the buffer.  Beware that if you go
ahead, not only do you lose any unsaved changes that you made to the
buffer, but the buffer's file name remains set, making it easy to
later accidentally overwrite the original file.  See also the variable
"wrap-process-lines".

:entry "shell-command-no-buffer" "Command"
This is just like "shell-command" except it just runs the command
without saving the output to any buffer.  It will report the success
of the command in the usual way.

:entry "shell-command-to-buffer" "Command"
This is just like "shell-command" except it lets you specify the
buffer to use.

:entry "shell-command-with-typeout" "Command"
This is just like "shell-command" except that instead of saving the
output to a buffer, and displaying it in a window, this just types out
the output in the same way that "list-buffers" does.  Actually, how
this behaves depends on the value of the variable "send-typeout-to-
buffer".  If it is "on" then "shell-command-with-typeout" will behave
just like "shell-command".  If a numeric argument is given, the
"completed successfully" message at the end is suppressed.

:entry "shell-flags" "Variable"
This specifies a flag argument that directs the shell to take the next
argument as a command to be executed.  The default is "-c" (suitable
for all known UNIX shells).  Under MSDOS, the default is "/c"
(suitable for command.com and similar MSDOS shells).  Other MSDOS
shells, such as MKS KSH require that this be changed to "-c".  Under
MSDOS, JOVE puts quotes around the command argument if "shell-flags"
starts with "-".  See the "shell" variable to change the default
shell.

:entry "shift-region-left" "Command"
This shifts the region left by "c-indentation-increment" OR by the
numeric argument, if one is supplied.  If a negative argument is
supplied the region is shifted the other way.

:entry "shift-region-right" "Command"
This shifts the region right by "c-indentation-increment" OR by the
numeric argument, if one is supplied.  If a negative argument is
supplied the region is shifted the other way.

:entry "show-match-mode" "Command"
This turns on or off the Show Match minor mode in the selected buffer.
Without a numeric argument, the command toggles the mode; with a zero
argument, the mode is turned off; with a non-zero argument, the mode
is turned on.  This mode changes "}", ")" and "]" so that when they
are typed they are inserted as usual, and then the cursor flashes back
to the matching "{", "(" or "[" (depending on what was typed) for
about half a second, and then goes back to just after the "}", ")" or
"]" that invoked the command.  This is useful for typing in
complicated expressions in a program.  You can change how long the
cursor sits on the matching parenthesis by setting the "paren-flash-
delay" variable in tenths of a second.  If the matching "{", "(" or
"[" isn't visible, the line containing the match is displayed on the
message line.

:entry "shrink-window" "Command"
This makes the active window one line shorter, if possible.  Windows
must be at least 2 lines high, one for the text and the other for the
mode line.  See also "grow-window".

:entry "source" "Command"
This reads a bunch of JOVE commands from a file.  If a numeric
argument is supplied to the "source" command, it will quietly do
nothing if it cannot read the file.

The format of the file is the same as that in the "jove.rc" file, or
your private ".joverc" in your home directory.  There should be one
command per line and it should be as though you were responding to an
"execute-named-command" command while in JOVE.  A command can be
optionally preceded by a numeric argument.  Lines commencing with a #
are treated as comments.  Control characters such as ^R may be
represented as themselves, or as "^" followed by "R".  ESC should be
represented by ^[.

Sometimes it is useful to do different things in different
circumstances.  To make this possible, there are two conditional
commands:  "if" and "ifenv".  The "if" command takes as an operand a
shell command, which it runs.  If the command succeeds, the commands
after the "if", until a line containing "else" or "endif", are
performed.  Otherwise, these commands are suppressed and the commands
after any "else", up until an "endif", are executed.  Conditionals
nest in the normal way.  The "ifenv" command takes as operands the
name of an environment variable and a pattern.  If the environment
variable is defined and its value matches the pattern, the "ifenv"
succeeds.

For example, here are some lines from the file "jove.rc".

     bind-to-key pause-jove ^[S
     bind-to-key pause-jove ^[s
     set process-prompt ^[^%$#]*[%$#]
     # source any TERMinal-specific rc file
     1 source jove.rc.$TERM

What they do is to provide two alternative key bindings for "pause-
jove", set the variable "process-prompt", and attempt to call the
"source" command on the file "jove.rc.$TERM".  Because of the numeric
argument 1, there will be no complaint if this file cannot be found.

:entry "space-sentence-2" "Variable"
If set "on", two spaces are left after each sentence by commands such
as "fill-paragraph"; otherwise, one space is left.  The default is
"on".

:entry "spell-buffer" "Command"
This runs the selected buffer through the UNIX "spell" program and
places the output in buffer "Spell".  Then JOVE lets you edit the list
of words, expecting you to delete the ones that you don't care about,
i.e., the ones you know are spelled correctly.  Then the "parse-
spelling-errors-in-buffer" command comes along and finds all the
misspelled words and sets things up so the error commands "next-
error", "previous-error" and "current-error" work.  See also the
variable "error-window-size".

:entry "split-current-window" "Command"
This splits the active window into two equal parts (providing the
resulting windows would be big enough) and displays the selected
buffer in both windows.  Use "delete-other-windows" to go back to 1
window mode.  If a numeric argument is supplied, the window is split
"evenly" that many times (when possible).

:entry "start-remembering" "Command"
This is just another name for the "begin-kbd-macro" command.  It is
included for backward compatibility.

:entry "stop-process" "Command"
Send the signal SIGTSTP to the interactive process in the selected
buffer.  This is equivalent to sending the "stop" character (which
most people have bound to ^Z) to the process.  This only works if you
are in a buffer bound to an interactive process.

:entry "stop-remembering" "Command"
This is just another name for the "end-kbd-macro" command.  It is
included for backward compatibility.

:entry "string-length" "Command"
This prints the number of characters in the string that point sits in.
Strings are surrounded by double quotes.  JOVE knows that "\007" is
considered a single character, namely "^G", and also knows about other
common ones, like "\r" (Return) and "\n" (Linefeed).  This is mostly
useful only for C programmers.

:entry "suspend-jove" "Command"
This is a synonym for "pause-jove".

:entry "sync-frequency" "Variable"
The temporary files used by JOVE are forced out to disk every "sync-
frequency" modifications.  The default is 50, which really makes good
sense.  Unless your system is very unstable, you probably shouldn't
fool with this.

:entry "tab-width" "Variable"
When JOVE displays a Tab character, it moves point forward to the next
multiple of this variable.  If the value is 0, tab is displayed as ^I,
not whitespace.  The default value is 8.

:entry "tag-file" "Variable"
This is the name of the file in which JOVE should look up tag
definitions.  The default value is "./tags".

:entry "text-attribute" "Variable"
(IBM PC version only) This specifies the screen attribute (color) for
normal text characters.  The default is 7 (white on black).

:entry "text-mode" "Command"
This sets the major mode to Text.  This affects what JOVE considers as
characters that make up words.  For instance, Single-quote is not part
of a word in Fundamental mode, but is in Text mode.

:entry "tmp-file-pathname" "Variable"
This tells JOVE where to put the tmp files, which is where JOVE stores
buffers internally.  The default is in "/tmp", or as set up when your
system was compiled, but if you want to store them somewhere else, you
can set this variable.  If your system crashes a lot it might be a
good idea to set this variable to somewhere other than "/tmp" because
the system removes all the files in "/tmp" upon reboot, and so you
would not be able to recover editor buffers using the "jove -r"
command.

NOTE: In order for this to work correctly you must set this variable
BEFORE JOVE creates the tmp file.  You can set this in your ".joverc"
(the closer to the beginning the better), or as soon as you start up
JOVE before you read any files.

:entry "transpose-characters" "Command"
This switches the character before point with the one after point, and
then moves forward one.  This doesn't work at the beginning of the
line, and at the end of the line it switches the two characters before
point.  Since point is moved forward, so that the character that was
before point is still before point, you can use "transpose-characters"
to drag a character down the length of a line.

:entry "transpose-lines" "Command"
This switches the current line with the one above it, and then moves
down one so that the line that was above point is still above point.
This, like "transpose-characters", can be used to drag a line down a
page.

:entry "unbound" "Command"
This command acts as if an unbound key sequence were typed.  In fact,
that is its use: if you wish to unbind a key sequence, simply bind it
to this command.

:entry "update-time-frequency" "Variable"
How often the mode line is updated (and thus the time).  The default
is 30 seconds.

:entry "use-i/d-char" "Variable"
If your terminal has insert/delete character capability you can tell
JOVE not to use it by setting this to "off".  In my opinion it is only
worth using insert/delete character at low baud rates.  WARNING: if
you set this to "on" when your terminal doesn't have insert/delete
character capability, you will get weird (perhaps fatal) results.

:entry "version" "Command"
Displays the version number of this JOVE.

:entry "visible-bell" "Variable"
If the terminal has a visible bell, use it instead of beeping.

:entry "visible-spaces-in-window" "Command"
This displays an underscore character instead of each Space in the
window and displays a greater-than followed by spaces for each Tab in
the window.  The actual text in the buffer is not changed; only the
screen display is affected.  To turn this off you run the command
again; it toggles.

:entry "visit-file" "Command"
This reads a specified file into the selected buffer replacing the old
text.  If the buffer needs saving JOVE will offer to save it for you.
Sometimes you use this to start over, say if you make lots of changes
and then change your mind.  If that's the case you don't want JOVE to
save your buffer and you answer "NO" to the question.

:entry "window-find" "Command"
This lets you select another buffer in another window three different
ways.  This waits for another character which can be one of the
following:

     T    Finds a tag in the other window.
     ^T   Finds the tag at point in the other window
     F    Finds a file in the other window.
     B    Selects a buffer in the other window.

This is just a convenient short hand for "split-current-window" (or
"previous-window" if there are already two windows) followed by the
appropriate sequence for invoking each command.  With this, though,
there isn't the extra overhead of having to redisplay.  In addition,
you don't have to decide whether to use "split-current-window" or
"previous-window" since "window-find" does the right thing.

:entry "word-abbrev-mode" "Command"
This turns on or off Word Abbrev minor mode in the selected buffer.
Without a numeric argument, the command toggles the mode; with a zero
argument, the mode is turned off; with a non-zero argument, the mode
is turned on.  Word Abbrev mode lets you specify a word (an
abbreviation) and a phrase with which JOVE should substitute the
abbreviation.  You can use this to define words to expand into long
phrases, e.g., "jove" can expand into "Jonathan's Own Version of
Emacs"; another common use is defining words that you often misspell
in the same way, e.g., "thier" => "their" or "teh" => "the".  See the
information on the "auto-case-abbrev" variable.

There are two kinds of abbreviations: mode specific and global.  If
you define a Mode specific abbreviation in C mode, it will expand only
in buffers that are in C mode.  This is so you can have the same
abbreviation expand to different things depending on your context.
Global abbreviations expand regardless of the major mode of the
buffer.  The way it works is this: JOVE looks first in the mode
specific table, and then in the global table.  Whichever it finds it
in first is the one that's used in the expansion.  If it doesn't find
the word it is left untouched.  JOVE tries to expand words when you
type a punctuation character or Space or Return.  If you are in Auto
Fill mode the expansion will be filled as if you typed it yourself.

:entry "wrap-process-lines" "Variable"
If this variable is "on", the process output that is captured in a
buffer is wrapped just before the line would have as many characters
as there are columns on the screen.  This introduces extra newlines,
but it makes the output more readable.  Note that the folding does not
take into account that some characters (notably tabs) occupy more than
one column of the display.  The output of the "filter-region" command
is not processed in this way because the extra newlines are presumed
to be undesired in this case.

:entry "wrap-search" "Variable"
If set, searches will "wrap around" the ends of the buffer instead of
stopping at the bottom or top.  The default is "off".

:entry "write-file" "Command"
This saves the selected buffer to a specified file, and then makes
that file the default file name for this buffer.  If you specify a
file that already exists you are asked to confirm over-writing it.

:entry "write-files-on-make" "Variable"
When set, all modified files will be written out before calling make
when the "compile-it" command is executed.  The default is "on".

:entry "write-macros-to-file" "Command"
This writes the currently defined macros to a specified file in a
format appropriate for reading them back in with the "source" command.
The purpose of this command is to allow you to define macros once and
use them in other instances of JOVE.  See also the "define-macro"
command.

:entry "write-modified-files" "Command"
This saves all the buffers that need saving.  If you supply a numeric
argument it asks, for each buffer, whether you really want to save it.

:entry "write-region" "Command"
This writes the text in the region to a specified file.  If the file
already exists you are asked to confirm over-writing it.

:entry "write-word-abbrev-file" "Command"
This writes the currently defined abbreviations to a specified file.
They can be read back in and automatically defined with "read-word-
abbrev-file".

:entry "xj-mouse-commands" "Command"
Programs such as XJove and JoveTool generate these commands whenever a
mouse button is pressed or released, or the mouse is moved while the
button is pressed.  They are followed by parameters giving parameters
for the button pressed, the coordinates of the mouse, etc.  They are
not intended for direct use by the normal user.

The individual commands will now be described.

:entry "xj-mouse-copy-cut" "Command"
Performs a "copy-region" if the CTRL key was down, or a "kill-region"
if both CTRL and SHIFT were down.  This command is normally bound to
the release of button 2.

:entry "xj-mouse-line" "Command"
Sets the region to be the whole line containing the cursor.  This
command is normally bound to a triple down click of button 2, and the
presumed effects of the preceding double click are first undone.

:entry "xj-mouse-mark" "Command"
Both point and mark are set to the cursor.  This command is normally
bound to the pressing of button 2.

:entry "xj-mouse-point" "Command"
Point is set to the cursor.  This command is normally bound to the
single, double, and triple down-click and the dragging of button 1;
also the dragging of button 2.

:entry "xj-mouse-word" "Command"
Sets the region to be the word (or the gap between two words)
containing the cursor.  This command is normally bound to a double
down click of button 2, and the presumed effects of the preceding
single click are first undone.

:entry "xj-mouse-yank" "Command"
Performs a "yank" if the CTRL key was down.  This command is normally
bound to the release of button 1.

:entry "xt-mouse" "Variable"
When set, JOVE sends XTerm escape sequences to enable and disable the
mouse messages at appropriate times.  Warning: due to the way XTerm
encodes mouse events, if "meta-key" is set, mouse actions beyond
column 95 or row 95 will be misunderstood; in any case, mouse actions
beyond column 223 or row 223 will be misunderstood.

:entry "xt-mouse-commands" "Command"
Programs such as XTerm generate these commands whenever a mouse button
is pressed or released.  XTerm does not give the user as much power as
XJove.  They are followed by parameters specifying the button pressed,
the coordinates of the mouse, etc.  They are not intended for direct
use by the normal user.  Set the variable "xt-mouse" on to enable
XTerm mouse mode.

The individual commands will now be described.

:entry "xt-mouse-mark" "Command"
Both point and mark are set to the cursor.  This command is normally
bound to the pressing of button 2.

:entry "xt-mouse-point" "Command"
Point is set to the cursor.  This command is normally bound to the
down-click of button 1.

:entry "xt-mouse-up" "Command"
As the name implies, this command is normally bound to the release of
any button (XTerm does not specify which button was released).  Note
that a normally configured XTerm will not pass on mouse events if the
CTRL or SHIFT keys are pressed.  Point is set to the cursor.  If the
most recently pressed button was button 1 and the CTRL key was down
(and not the SHIFT key), this command performs a "yank".  If the most
recently pressed button was button 2 and the CTRL key was down, this
command performs a "copy-region".  If the most recently pressed button
was button 2 and the CTRL and SHIFT keys were down, this command
performs a "kill-region".

:entry "yank" "Command"
This inserts the text at the front of the kill ring (as set by an
earlier "copy-region", "kill-region", etc.) at point.  When you do
multiple kill commands in a row, they are merged so that the "yank"
command yanks back all of them.

:entry "yank-pop" "Command"
JOVE has a kill ring on which the last sixteen kills are stored.  This
command yanks back previous texts from the kill ring.  "yank" yanks a
copy of the text at the front of the ring.  If you want one of the
last sixteen kills you then use "yank-pop" which rotates the ring so
another different entry is now at the front.  You can use "yank-pop"
only immediately following a "yank" or another "yank-pop".  If you
supply a negative numeric argument the ring is rotated the other way.
If you use this command enough times in a row you will eventually get
back to where you started.
